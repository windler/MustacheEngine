package de.jawi.engine.mustacheengine.game.texture;

import java.util.Hashtable;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.util.Log;
import de.jawi.engine.mustacheengine.game.Bitmap.GameBitmap;
import de.jawi.engine.mustacheengine.game.Bitmap.GameBitmapPool;
import de.jawi.engine.mustacheengine.game.engine.GameEngine;
import de.jawi.engine.mustacheengine.game.font.Font;
import de.jawi.engine.mustacheengine.game.util.POTHelper;

/**
 * Der TextureManager kümmert sich um die Verwaltung von Texturen. Sie können
 * geladen, freigesetzt werden. Es wird geprüft, ob eine Texture POT ist (power
 * of two). Falls nicht wird eine Texture mit nächst größter POT erstellt.
 * 
 * Eine Gruppe ist eine id, unter der die Cachables in den Cache geladenw erden.
 * So können alle Cachable aus dem Cache entfernt werden, die einer Gruppe
 * angehören (bei push/pop vom GameScreenManager sinnvoll)
 * 
 * @author windler
 * 
 */
public class TextureManager {

	private GameBitmapPool gameBitmapPool;
	private Hashtable<Integer, Texture> loadedTextures;
	private Hashtable<String, Font> fonts;
	private GameEngine gameEngine;
	private int idCount = 0;

	/**
	 * Erstellt einen neuen TextureManager
	 * 
	 * @param engine
	 */
	public TextureManager(GameEngine engine) {
		loadedTextures = new Hashtable<Integer, Texture>();
		fonts = new Hashtable<String, Font>();
		gameEngine = engine;
		gameBitmapPool = new GameBitmapPool(10000, 10);
	}

	/**
	 * Lädt die Texturen anhand der IDs. Die IDs müssen von R.drawable kommen
	 * 
	 * @param ids
	 */
	public void loadTextures(int[] ids) {
		for (int id : ids) {
			if (loadedTextures.get(id) == null) {
				createTexture(id);
			}
		}
	}

	/**
	 * enfernt die Texturen und setzt den Speicher frei. ACHTUNG: GC wird
	 * aufgerufen!
	 * 
	 * @param ids
	 */
	public void unloadTextures(int[] ids) {
		for (int id : ids) {
			if (loadedTextures.get(id) != null) {
				loadedTextures.remove(id);
			}
		}

		System.gc();
	}

	/**
	 * Erstellt ein Gamebitmap anhand eines geladenen Bitmap (POT)
	 * 
	 * @param id
	 * @param position
	 * @return
	 */
	public GameBitmap getGameBitmapFromPool(int id) {
		Texture txt = loadedTextures.get(id);
		GameBitmap gbmp = gameBitmapPool.getPoolItem();
		if (txt == null) {
			throw new IllegalArgumentException(
					"Couldn't find Texture with id: " + id + ". Was it loaded?");
		}
		gbmp.init(txt);
		return gbmp;
	}

	/**
	 * Recyclet das GB und fügt es in den Pool
	 * 
	 * @param bmp
	 */
	public void recycleGameBitmap(GameBitmap bmp) {
		gameBitmapPool.recyclePoolObject(bmp);
	}

	private void createTexture(int id) {
		Bitmap bmp = decodeBmp(id);

		Texture newTxt = new Texture(++idCount);
		newTxt.setTextureWidth(bmp.getWidth());
		newTxt.setTextureHeight(bmp.getHeight());

		bmp = POTHelper.createPOT(bmp);
		newTxt.setPotBmp(bmp);

		loadedTextures.put(id, newTxt);
	}

	private Bitmap decodeBmp(int id) {
		BitmapFactory.Options bfo = new BitmapFactory.Options();
		bfo.inScaled = false;
		Bitmap bmp = BitmapFactory.decodeResource(gameEngine.getContext()
				.getResources(), id, bfo);
		return bmp;
	}

	/**
	 * liefert den Font zurück
	 * 
	 * @param key
	 * @return
	 */
	public Font getFont(String key) {
		return fonts.get(key);
	}

	/**
	 * fügt ein Font hinzu und macht aus dem Bitmaps POT's
	 */
	public void addFont(Font f) {
		if (f != null) {
			fonts.put(f.getName(), f);
		} else {
			Log.e("Register Font", "Font nicht initialisiert.");
		}
	}

	/**
	 * Lädt alle geladen Textures erneut
	 */
	public void reloadTextures() {
		for (int id : loadedTextures.keySet()) {
			Texture t = loadedTextures.get(id);
			t.setPotBmp(POTHelper.createPOT(decodeBmp(id)));
		}
	}

}
